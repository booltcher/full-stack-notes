优化不是一招致胜，也不是一劳永逸，我们的项目在不断的迭代中，要求我们的优化策略和手段也同步更新。所以说和我们的开发迭代工作是同步或交替进行的。

#### 从输入URL到页面加载，发生了什么?

- **DNS解析** 通过DNS将域名解析为ip
- **TCP连接** 与对应ip的主机建立网络连接（滑动窗口，慢启动） -> 与之对应不可靠的协议UDP

- **HTTP请求** 发送http请求
- **HTTP响应** 服务端响应请求并将结果返回（SPA - 一个空的html，一个css，一个js 执行完毕有内容 ； SSR）

- **渲染** 浏览器渲染



所以优化大体就是对这这个流程具体的五个步骤优化：

**1.DNS 解析花时间，能不能尽量减少解析次数或者把解析前置** 

- 浏览器 DNS 缓存
- DNS prefetch



**2.TCP 每次的三次握手都急死人，有没有解决方案** 

- 长连接
- 预连接

- 接入 SPDY 协议



**3.HTTP请求过慢** 

- 减少请求次数
- 减少单次请求所花费的时间

- 选择合适的CDN



**4.浏览器端（重头戏）**

- 资源加载优化
- 服务端渲染

- 浏览器缓存机制的利用
- DOM树的构建

- 网页排版和渲染
- 回流，重绘

- DOM的合理操作

浏览器内核：1GUI渲染线程，2Javascript引擎线程，3事件触发线程，4定时触发器线程，5Http异步请求线程



##### Gzip

Http压缩



##### 图片

《高性能网站建设指南》的作者史蒂夫·桑德斯曾在 2013 年的一篇博客中提到过他和他的团队一直致力于如何优化Javascript和css，但几个月后才发现他们错了，真正重要的是图片。

图片与其说优化不如说**“权衡**”，在体积和质量间做权衡，尽可能找到体积和质量间的一个平衡点。

一个网站 httparchive [ˈɑːkaɪv]：它会定期抓取 Web 上的站点，并记录资源的加载情况、Web API 的使用情况等页面的详细信息，并会对这些数据进行处理和分析以确定趋势。其中请求图片占比接近50%。



##### 二进制位数和色彩的关系

计算机中，像素用二进制数来表示，一个像素对应的二进制位数越多，可以表示颜色的种类就越多，越细腻，相应的文件体积就会越大。



##### JPG/JPEG - 有损压缩，体积小，加载快，不支持透明

优点：通过有损压缩技术，体积减少50%，但是质量还能保持在60%以上

缺点：处理矢量图形和Logo等线条感较强，颜色对比强烈的图像时，会明显模糊，且不支持透明度

使用场景：大背景，banner



##### PNG-8/PNG-24 - 无损压缩，质量高，体积大，支持透明

优点：更加细腻

缺点：体积太大

使用场景：Logo



##### SVG - 文本文件，体积小，不失真，兼容性好

和其他图像类型本质不同，对于图像的处理不是基于像素点，而是基于对图像的形状描述

优点：体积更小，可压缩性更强，最重要的是无限放大不失真

缺点：渲染成本高，学习成本高(可编程的)



##### Base64 - 文本文件，依赖编码，小图标解决方案

并非图片格式，而是一种编码方式

优点：通过对图片进行 Base64 编码，浏览器可以直接理解这个字符串，而不用再去发送HTTP请求。

缺点：编码后图片的体积会膨胀到原来的4/3

使用场景：实际尺寸很小，更新频率低



##### WebP - 年轻的全能选手

优点：细腻，支持透明，可动态，支持无损压缩和有损压缩

缺点：兼容性差，服务器端负担重(要使用更多的计算资源)

在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。



##### CSS Sprites雪碧图

多个小图标合并到一张图片上，然后利用CSS的背景定位来显示其中的每一部分

单独一张图片所需要的的HTTP请求更少，对内存和带宽更加友好



#### 浏览器缓存

1. Memory Cache
2. Service Worker Cache

1. HTTP Cache
2. Push Cache



##### HTTP缓存机制

##### 一.强缓存

强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，**不会再与服务端发生通信。**



强缓存的实现：从 expires 到 cache-control

**绝对的时间戳：**expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 expires 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求，若服务器与客户端存在时差，将带来意料之外的结果。

```javascript
cache-control: max-age=31536000
```

**相对的时间长度：**max-age 不是一个时间戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的两个时间节点（起始时间和当前时间）都来源于客户端，由此便能够实现更加精准的判断。

**Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。**

#### no-store与no-cache

no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。

no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。



```javascript
cache-control: max-age=3600, s-maxage=31536000
```

**s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。**





##### 协商缓存：浏览器与服务器合作之下的缓存策略

协商缓存依赖于服务端与浏览器之间的通信。

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。

如果服务端提示缓存资源未改动（Not Modified），资源会被**重定向**到浏览器缓存，**这种情况下网络请求对应的状态码是 304**（如下图）。



协商缓存的实现：从 Last-Modified 到 Etag

Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：

```plain
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
```

随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

```plain
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
```

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回304 响应，Response Headers 不会再添加 Last-Modified 字段。

使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：

- 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。
- 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

Etag 是由服务器为每个资源生成的唯一的**标识字符串**

 **Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。**



1. **当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；**
2. **否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；**

1. **否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；**
2. **然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。**



##### MemoryCache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。



##### Servive Work Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。



### 存储篇

#### Cookie

- 本质就是存储在浏览器中的一个小的文本文件
- 以键值对形式存储

- 在浏览器和服务器之间来回传递，携带用户信息



##### 缺点

- 最大4KB
- 同一域名下的所有请求都会携带Cookie，所以有很多请求不必要携带Cookie，大量不必要的开销



#### WebStorage

- 存储量大
- 仅位于浏览器端，不与服务器发生通信

API：

```
getItem
setItem
removeItem
clear
```



#### LocalStorage

- 持久化本地存储，必须手动删除



#### SessionStorage

- 临时性的本地存储，会话级别的本地存储，当会话结束，页面被关闭，存储内容就被释放



##### 缺点

- 存储简单的键值对，对象都必须先进行处理





#### IndexedDB

运行在浏览器上的非关系型数据库



### CDN

- 缓存 - 数据copy一份放到cdn服务器上
- 回源 - 发现没有某些资源，转而向根服务器或者上册服务器请求这个资源



静态资源走cdn并不是一个建议，对于一线大厂是一个规定



### 渲染篇



#### 客户端渲染和服务器端渲染



客户端渲染：服务器把渲染所需要的的静态文件发送给客户端，客户端加载过来之后，在浏览器里跑一遍JS，根据运行结果，生成相应的DOM，客户端执行的源代码总是很简洁。

**页面上呈现的内容，你在 html 源文件里里找不到**



用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。

**“所见即所得”，****页面上呈现的内容，我们在 html 源文件里也能找到**。

（知乎就是一个SSR案例）



选择SSR其实很多时候是出于效益(SEO)，其次才是性能。但是并不代表性能不重要。服务器端渲染解决了首屏加载速度过慢。

但是SSR成本很高，作为优化的最终解决方案。



#### 浏览器内核

- webkit(Safari)
- trident(IE)

- gecko(火狐)
- Blink(Chrome，Opera) - 实际是Webkit分支



渲染过程：

- parseHTML - HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。
- Style - CSS 解释器：解析 CSS 文档, 生成样式规则(cssom)。将样式信息和dom树合并，生成render树

- Layout - 图层布局计算模块：布局计算每个对象的精确位置和大小。
- Paint - 视图绘制模块：进行具体节点的图像绘制，将每一个页面图层转换为像素，将像素渲染到屏幕上。并对媒体文件进行解码。

- Composit - 整合：合并各个图层，数据由CPU传给GPU最终绘制出页面。

**CSSOM的解析过程和DOM的解析过程是并行的。**



#### CSS的优化

CSS选择符是从右到左进行匹配的。

- 避免使用通配符
- 关注可以通过继承实现的属性，避免重复匹配重复定义。

- 少用标签选择器。尽可能用类选择器
- 减少嵌套，将选择器的深度降到最低



#### CSS和JS的加载顺序优化



##### CSS的阻塞

cssom的解析不完成，即使dom的解析完成了，也得等CSSOM和DOM合力构建渲染树

所以需要将CSS**尽早(将css放在head标签里)尽快(CDN)**地下载带客户端，以便缩短首次渲染时间。



##### JS的阻塞

JS引擎是独立于渲染引擎存在的，当HTML解析器遇到一个script标签是，会暂停渲染，将控制权交给JS引擎。



JS引擎拿到控制权，对内联的JS代码会直接执行，对外部的JS文件要先获取脚本，再执行。等JS执行完毕，浏览器又会把控制权交换给渲染引擎。



为什么会这样？因为浏览器不知道JS会进行什么操作，做哪些改变，如果不阻止渲染引擎，可能出现混乱。但是写代码的人是知道JS的作用的，所以我们可以确认一个JS的执行时机，并不一定非在此时此刻，可以审时度势使用defer和async 来避免不必要的阻塞。这就是JS的三种加载方式。

- 正常模式 - 阻塞浏览器，等待JS加载和执行完毕。

```javascript
<script src="index.js"></script>
```

- async模式 - 异步加载，不会阻塞浏览器

```javascript
<script async src="index.js"></script>
```

- defer模式 - 推迟的，等整个文档解析完成才会开始依次执行。

```javascript
<script defer src="index.js"></script>
```



#### DOM优化原理

为什么慢？

因为每次JS在操作DOM的时候，涉及到两个模块之间的协作，JS引擎和渲染引擎，实际上发生了跨界交流，通过桥接接口实现。

每操作一次DOM，都要过一次桥，所以尽可能减少DOM操作会明显提升性能。而且DOM的操作可能会引起回流和重绘。



#### 回流和重绘

回流(重排)：DOM的几何尺寸发生变化。重新计算然后绘制。

重绘：样式的变化。重新绘制。

重绘不一定导致回流，但回流一定会导致重绘。



- 减少DOM操作次数
- 让JS为DOM分压：1.DOM Fragment(DOM碎片)2.异步更新(渲染引擎只关注结果，不需要为过程买单)

DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。

就是作为一个容器，缓存DOM的批量操作。



Vue想要更新一个状态的时候，会先把跟心操作包装成一个异步操作派发出去，源码中是由一个叫nextTick的函数来完成的。

nextTick默认是用Promise包装的。

Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。



##### 如何尽可能减少回流和重绘

1. 用JS变量缓存DOM属性
2. 避免逐条更新样式，使用类名合并

1. DOM离线，先从DOM树中拿掉，更新后再放回去





#### 懒加载Lazy-load



性能指标：

- FP - 首次绘制
- FCP - 首次内容绘制

- FMP - 首次有效绘制
- TTI - 可交互时间

工具：

- lightHouse



#### Gzip

通过HTTP压缩，在客户端请求服务器的资源后，从服务端将资源文件压缩，再输出到客户端，浏览器端再解压缩





vue3的改进 把一些更底层的东西暴露出来，把一些代码封装成单独的包

1. vue2中响应式实现核心是依赖的收集和派发，响应式对象更新的时候去重新渲染
2. vue3中reactive()就是vue2的Vue.obervabal()，进行响应式处理，这些响应式的值会产生某些副作用，当依赖更新时，副作用的函数再执行一遍

1. 1. reactive
   2. ref

1. 1. watchEffect